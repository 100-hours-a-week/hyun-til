# TIL Template

## 날짜: 2025-01-16

### 스크럼
- 학습 목표 1 : 면접 스터디를 위한 데이터베이스 공부


### 오늘의 도전 과제와 해결 방법
- 도전 과제 1 : 데이터 베이스 면접 정리

> **💡** 데이터 베이스란 무엇인가요?

데이터 베이스는 일정한 규칙을 통해 구조화 되어 저장되는 데이터의 모음입니다. 데이터 베이스를 관리하는 통합 시스템을 DBMS라고 하며 데이터베이스 안에 데이터들은 DBMS를 통해 상호작용합니다.


> **💡** 중첩 루프 조인이 무엇인가요?


중첩 루프 조인은 중첩 for문과 같은 원리로 조건에 맞는 조인을 하는 방법이며, 랜덤 접근에 대한 비용이 많이 증가하므로 대용량의 테이블에서는 사용하지 않습니다. 테이블 두개를 조인 한다고 하였을때 첫번째 테이블에서 행을 한번에 하나씩 읽고 그다음 테이블에서도 행을 하나씩 읽어 조건에 맞는 레코드를 찾아 결과값을 반환합니다.

> **💡** 인덱스가 오히려 성능을 악화시키는 사례도 있습니다. 성능 악화는 어떤 상황에서 발생하는지, 그래서 인덱스는 언제, 어떻게 사용해야 하는지에 대해 설명해보세요

인덱스를 사용하면 select 연산에 대한 성능을 향상 시킬 수 있지만 insert, update, delete와 같은 연산에는 성능이 저하 될 수 있습니다. 새로운 데이터를 삽입하거나 기존 데이터를 수정/삭제 하는 경우 인덱스도 함께 갱신해야 하기 때문입니다. 따라서 인덱스는 데이터가 많고 조회가 빈번한 테이블에 사용하며 중복 데이터가 많지 않은 열 이나 join, where에서 자주 참조 되는 열에 생성하는것이 효율적 입니다.

<aside>

> **💡** 일 시스템 대신 데이터 베이스를 이용하는 이유 무엇일까요?

</aside>

파일 시스템은 데이터 일관성과 무결성 제공이 어렵습니다. 파일 시스템에서 여러 사용자나 프로그램이 동시에 데이터를 사용하는 경우, 레이스 컨디션 등의 문제로 데이터 일관성이 깨지기 쉽습니다. 또한 데이터 변경시 연관 데이터 변경이 어렵습니다. 하나가 변경되면 일일이 변경을 해줘야합니다. 그리고 백업 및 복구가 어렵습니다. 데이터베이스는 동시 다발적으로 이용하기 때문에 데이터베이스에서 백업과 복구 기능을 제공합니다. 하지만 파일 시스템에서는 이러한 기능을 제공하지 않거나 데이터베이스에 비해 부족한 수준으로 지원합니다. 따라서 대량의 데이터를 관리하며 여러 사용자에게 제공을 해야한다면 파일 시스템보다는 데이터 베이스를 사용하는 것이 효율적입니다.

<aside>

> **💡** 클러스터형 인덱스와 세컨더리 인덱스가 무엇인가요?

</aside>

테이블내의 기본키로 지정된 필드는 기본적으로 클러스터형 인덱스로 간주됩니다. 세컨더리 인덱스는 클러스터형 인덱스가 아닌 인덱스입니다. 테이블당 여러개가 존재 할 수 있습니다.

<aside>

> **💡** 트랜잭션과 ACID가 무엇인지 설명해보세요

</aside>

트랜잭션은 커밋을 발생시키는 논리적인 단위이며 ACID는 안전한 트랜잭션이 지켜야 할 4가지 특성인 원자성, 일관성, 격리성, 지속성을 의미합니다. 원자성은 트랜잭션의 모든 작업이 성공하거나 실패함을 보장하는 성질이며 일관성은 트랜잭션 전후 데이터베이스의 일관된 상태를 유지하는 성질, 격리성은 동시에 수행되는 트랜잭션 간의 간섭이 불가능하도록 보장하는 성질, 지속성은 완료된 트랜잭션의 결과가 영구적으로 반영되는 성질을 말합니다.

<aside>

> **💡** 기본 키가 무엇이며 어떤 조건을 만족해야 하는지 설명해보세요

</aside>

기본키는 데이터베이스 테이블에서 각 행을 고유하게 식별하기 위해 선정된 키를 말합니다. 기본 키는 유일성을 갖추어 중복되지 않아야하고, 반드시 값이 존재해야 하므로 null값을 가질수없습니다. 또한 행을 식별하기위한 최소한의 정보로 구성되어야합니다.

<aside>

> **💡** 데이터 관리에 있어 정규화가 필요하지 않을때가 존재하는데 그 상황은 어떤 상황일까요?

</aside>

정규화는 데이터 일관성과 무결성을 높이지만 테이블을 많이 쪼개다보면 빈번해지는 조인 연산으로 인해 검색의 성능이 저하될 수 있습니다. 따라서 검색 성능이 중요한 경우에는 정규화가 필요하지 않을 수 있습니다.

<aside>

> **💡** 인덱스란 무엇이며 인덱스를 통해 어떻게 성능을 향상시킬 수 있는지 설명해보세요

</aside>

인덱스는 특정 테이블 열에 대한 자료구조로 검색 속도를 향상시키기 위해 사용합니다. 인덱스를 통해 원하는 데이터를 빠르게 조회 할 수 있습니다. 인덱스를 생성하면 해당 테이블의 열 값들이 정렬된 형태로 저장되므로 테이블 전체를 탐색하지 않고도 빠르게 데이터를 찾을 수 있어 검색 성능이 향상됩니다.

<aside>

> **💡** 인덱스에는 b트리 혹은 b+트리의 변형인 자료구조가 사용됩니다. 그 이유를 설명해보세요

</aside>

b트리 혹은 b+트리와 같은 b 트리의 변형은 대용량 데이터에 대한 빠른 탐색에 특화된 자료구조입니다. b트리는 균형 잡힌 트리 구조로써 데이터가 정렬된 상태로 저장되고, 각각의 노드가 여러개의 자식을 가질 수 있어 탐색을 위한 연산 횟수가 일반적인 트리에 비해 적습니다. 이렇게 원하는 레코드를 빠르게 탐색할 수 있기때문에 인덱스에서 주로 사용됩니다.

<aside>

> **💡** 참조 무결성 제약 조건에 대해 설명해 보세요

</aside>

참조 무결성 제약 조건이란 외래 키를 통해 테이블 간의 참조 관계에서 데이터의 일관성을 유지하기 위한 조건을 말합니다. 외리 키는 참조하는 테이블의 기본 키와 같은 값을 가지거나 null값을 가져야 합니다.

<aside>

> **💡** inner 조인과 outer 조인의 차이점에대해 설명해 보세요

</aside>

이너 조인은 조인 조건을 만족하는 행들만 결과에 포함되며 공통된 데이터가 있는 경우에만 데이터를 추출합니다.아우터 조인은 공통된 값이 없는 행도 포함하여 반환합니다. left 아우터 조인은 왼쪽 테이블의 모든 행과 오른쪽 테이블의 일치하는 값을 반환하고 일치하지 않는 경우는 null을 반환합니다. right 아우터 조인은 오른쪽 테이블의 모든 행과 왼쪽 테이블의 일치하는 값을 반환하고 일치 하지 앟는 경우 null을 반환합니다. full 아우터 조인은 양쪽 테이블의 모든 행을 반환하고 어느 한쪽에서 일치하는 값이 없는 경우 null을 반환합니다.

<aside>

> **💡** sql에서 뷰를 사용하는 목적을 설명해 보세요

</aside>

뷰는 sql 쿼리의 단순화 및 재사용성을 위해 사용합니다. 복잡한 쿼리를 자주 실행해야하는 경우 뷰를 생성하여 동일한 결과를 간단하게 얻을 수 있습니다. 또한 사용자에게 테이블의 특정 데이터만 보여주고자 할때 사용합니다.

<aside>

> **💡** noSQL 데이터베이스란 무엇이며 관계형 데이터베이스와 어떤 차이점이 있는지 설명해보세요

</aside>

관계형 데이터베이스는 테이블 기반의 구조로써 스키마가 고정되어있는 반면 비관계형 데이터 베이스인 NoSQL 데이터베이스는 데이터의 저장 및 관리를 위해 고정된 스키마가 없고 수평 확장이 용이한 구조를 가지고 있습니다. NoSQL 데이터베이스는 키-값, 도큐먼트, 그래프, 칼럼 패밀리 등의 다양한 형태로 저장할 수 있습니다.

<aside>

> **💡** 관계형 데이터베이스와 비교해 NoSQL 데이터베이스는 어떤상황에서 유리하고 어떤상황에서 불리한가요

</aside>

NoSQL 데이터베이스는 대규모의 비정형 데이터를 처리할 때, 높은 확장성과 빠른 읽기쓰기 성능이 필요할때 유리합니다. 그러나 엄격한 트랜잭션 관리나 데이터 일관성 보장, 관계형 데이터 모델링이 필요한 애플리케이션에는 관계형 데이터베이스가 더 적합합니다.

<aside>

> **💡** redis가 캐시 서버로써 동작하는 부차적인 데이터베이스로 유용하게 사용되는 이유는 redis의 어떤 특성때문인지 설명해 보세요

</aside>

redis는 인메모리 데이터베이스이기 때문에 디스크 접근 시간을 단축할 수 있습니다. 또한 redis는 여러 자료구조를 지원하는 키-값 데이터베이스로써 rdbms보다 정형화되어 있지 않은 데이터에 대한 빠른 입출력이 가능합니다. 따라서 rdbms을 주요 데이터베이스로삼고 redis를 캐시 역할을 수행하는 부차적인 데이터베이스로 삼으면 주요 데이터베이스의 입출력 성능을 상당 부분 보강할 수 있습니다.

<aside>

> **💡** 데이터베이스 샤딩이 무엇인지 설명해보세요

</aside>

샤드라는 단위로 여러 데이터베이스 서버에 걸쳐  테이블을 분할하여 저장하는 기술을 의미합니다. 

<aside>

> **💡** 인덱스를 어떤 컬럼에 사용하는 것이 좋을까요?

</aside>

인덱스는 where 절에서 자주 조회되고 수정 빈도가 낮고 카디널리티는 높으며 선택도가 낮은 컬럼을 선택해서 설정하는것이 좋습니다.

<aside>

> **💡** 데드락이 무엇인지 설명해 주세요

</aside>

여러 트랜잭션들이 각각 자신의 데이터에 대하여 락을 획득한 상태에서 상대방 데이터에 대하여 접근하고자 대기를 할때 교차 대기를 하게 되면서 서로 영원히 기다리는 상태를 말합니다.

<aside>

> **💡** 데드락을 해결하려면 어떻게 해야하나요

</aside>

여러가지 방법이 존재하는데 타임아웃을 설정하여 트랜잭션이 일정 시간 동안 자원을 획득하지 못하면 강제로 롤백하여 데드락을 해소합니다. 자원 획득 순서를 통제하여 특정 순서로 요청하도록 규칙을 정하면 데드락 발생을 줄일수있습니다.

<aside>

> **💡** 데이터를 검색하려고 할때 hash table의 시간 복잡도는 O(1)이고 b+tree는 O(log n)으로 더 느린데 왜 index는 hash table이 아니라 b+tree로 구현되나요?

</aside>

해시테이블을 사용하면 하나의 데이터를 탐색하는 시간은 O(1)으로 b+tree보다 빠르지만 값이 정렬되어 있지 않기 때문에 부등호를 사용하는 query에대해서는 매우 비효율적이게되어 데이터를 정렬해서 저장하는 b+tree를 이용합니다.

<aside>

> **💡** 데이터베이스 **동시성 제어**를 설명해주세요

</aside>

데이터베이스 동시성 제어란 동시에 실행되는 여러개의 트랜잭션이 작업을 성공적으로 마칠수 있도록 트랜잭션의 실행 순서를 제어하는 기법 입니다. 대표적으로는 락킹과 타입스탬프 기법이 존재합니다. 락킹은 트랜잭션이 데이터에 락을 설정하여 다른 트랜잭션이 해당 데이터에 접근/수정을 불가능하게 만드는 기법입니다. 타임스탬프는 트랜잭션에 타임스탬프를 부여하여 접근 순서를 미리 정하는 기법입니다.

<aside>

> **💡** 동시성 제어를 안하면 어떤 문제가 발생하나요?

</aside>

대표적으로는 갱신손실 문제와 더티리드 문제가 발생합니다. 갱신손실은 하나의 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어씀으로써 갱신이 무효화되는 상황을 의미합니다. 더티리드는 읽기 작업을 수행하는 트랜잭션 a가 쓰기 작업을 수행중인 트랜잭션 b가 작업한 중간 데이터를 읽는 상황을 의미합니다.

<aside>

delete truncate drop 명령어의 차이점을 설명해보세요

</aside>

delete는 데이터를 지우지만 테이블의 용량은 줄어들지 않고 삭제 후 복구가 가능합니다. truncate는 전체 데이를 한번에 삭제하여 테이블 용량도 줄어들고 인덱스도 삭제되지만 테이블 자체가 삭제되지는 않습니다. drop은 테이블 자체를 삭제하며 할당 공간까지 삭제합니다.

<aside>

> **💡** 정규화에 대해 설명해주세요

</aside>

하나의 릴레이션에 하나의 의미만 존재하도록 릴레이션을 분해하는 과정이며 데이터의 일관성 무결성을 유지하기위한 방법입니다. 

제 1 정규화는 데이터의 컬럼이 원자값(하나의 값)을 갖도록 테이블을 분해하는 것입니다.

제 2 정규화는 제 1 정규화를 만족하고 완전 함수 종속을 만족하도록 테이블을 분해하는 것입니다.

제 3 정규화는 제 2 정규화를 만족하고 이행정 종속을 없애도록 테이블을 분해하는 것입니다.

BCNF 정규화는 제 3 정규화를 만족하고 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것입니다.

<aside>

> **💡** 역정규화를 하는이유가 무엇인가요

</aside>

정규화를 거치면 테이블간의 join연산이 많아지는데 이로인해 성능저하가 발생 할 수 있습니다. 역정규화는 이러한 성능문제를 해결하기위함입니다.